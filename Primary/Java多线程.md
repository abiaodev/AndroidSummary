# Java多线程
## 1、基础知识
### 1.1 线程安全性
    当多个线程访问某个类的时候，这个类始终能保证正确的行为，这个类就是线程安全的。
#### 1.1.1 原子性
##### 1.1.1.1 竞态条件
    在并发编程中，由于不恰当的时序而出现的问题叫做竞态条件
    1、先检查后执行
##### 1.1.1.2 复合操作
    一组必须已原子方式执行的操作
#### 1.1.2 加锁机制
##### 1.1.2.1 内置锁
    同步代码块，包含一个作为锁的对象的引用，一个作为由这个锁保护的代码块。
    使用synchronized关键字修饰的方法就是横跨整个方法体的同步代码块，该代码块的锁是调用这个方法的对象。静态的synchronized方法以Class对象为锁。
    线程进入同步代码块时会自动获取锁，离开代码块时自动释放锁。
    内置锁相当于互斥体，同时只能有一个线程能获取锁，当一个线程想要去访问一个正在被访问的其他线程持有的锁时线程将会阻塞直到该锁被释放。
##### 1.1.2.2 重入
    因为内置锁时可重入的，所以如果某个线程想要获取一个它已经持有的锁的时候，这个请求将会成功。
#### 1.1.3 使用锁保护状态
    使用synchronized的缺陷：1、导致程序中出现过多的同步。2、无法解决多个操作合并的复合操作。3、可能会导致活跃性问题和性能问题。
#### 1.1.4 活跃性与性能
### 1.2 对象的共享
#### 1.2.1 可见性
    在多线程程序中，我们无法保证正在执行的线程可以适时的看到其他线程写入的值,甚至不能确保能看到写入值。
##### 1.2.1.1 失效数据
    当线程访问某个变量时，可能得到一个已经失效的值。还有一种情况，一个线程可能获得某个变量的最新值，而另一个线程获得失效得值。
    失效数据会导致：1、计算结果错误。2、活跃性和性能问题。3、意料之外的异常。
##### 1.2.1.2 非原子的64位操作
    最低安全性：线程在没有同步的情况下，访问某个变量时得到的值时之前某个线程设置的某个值而不是随机值。
    最低安全性不能保证非volatile类型的double和long，因为java虚拟机允许64位的读写操作分为两个32位的操作。这样可能会导致得到一个值的高32和另一个值的低32
##### 1.2.1.3 加锁与可见性
    加锁的意义不仅仅局限于互斥，还包括内存可见性。为了确保线程能看到最新值，所有执行读操作和写操作的线程再同一个锁中必须同步。
##### 1.2.1.4 volatile变量
    volatile时一种比synchronized更加轻量级的同步机制。加锁机制提供了互斥与可见性，但是volatile只确保可见性。
### 1.3 线程封闭
    不共享数据，只能再当前线程访问变量。是实现线程安全最简单的方式。
#### 1.3.1 Ad-hoc线程封闭
    维护线程安全性完全由程序来实现，要尽量避免使用这个方式实现线程封闭。
#### 1.3.2 栈封闭
    栈封闭是线程封闭的一种特例，在栈封闭中，只有通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中。
    防止线程封闭被破坏需要防止需要封闭的对象逸出。
#### 1.3.3 ThreadLocal
    这个类可以使线程中保存的某个值与保存值得对象关联起来。通常用于防止对可变得单实例变量或全局变量进行共享。
### 1.4 不变性
    不可变对象一定是线程安全的
    不可变对象：1、创建后其状态不可修改。2、所有域都是final型（也有例外，如String）。3、对象是正确创建的（在创建对象期间，this引用没有逸出）
#### 1.4.1 Final域
    Final域可以确保初始化的安全性,从而可以不受限制的访问不可变对象,并且在共享这些对象时无需同步。
### 1.5 安全发布
#### 1.5.1 不正确的发布
    如果对象没有正确的发布将会出现一些不可思议的错误，比如除了发布对象的线程之外，其他线程可能访问到一个失效的对象（可能时一个空或者之前的值）、可能看到的对象的引用值是最新的，但是对象的状态是失效的、或者某个线程第一次取到的是失效的值，第二次却取到最新值。
#### 1.5.2 不可变对象与初始化安全性
#### 1.5.3 安全发布的常用模式
  - 在静态初始化函数中初始化一个对象引用（静态初始化器由JVM在类的是初始化阶段进行，JVM
  内部存在同步机制）
  - 将对象的引用保存volatile类型的域或者AtomicReference对象中
  - 将对象的引用保存到某个正确构造对象的final域中
  - 将对象的引用保存到由锁保护的域中
#### 1.5.4 事实不可变对象
    如果对象从技术上来看是可改变，但是一经发布之后状态不可变，我们称之为事实不可变对象。事实不可变对象可不用满足不可变性的约束就能满足对象的安全发布。
#### 1.5.5 可变对象
    可变对象必须通过安全的方式发布，并且必须是线程安全的或者由某个锁保护起来。
#### 1.5.6 安全的共享对象
  - 线程封闭
    > 只能由一个线程拥有，对象被封闭在线程中，只能由当前线程修改

  - 只读共享
    > 在没有额外同步的情况下，共享只读对象可以由多个线程访问，但是不能修改。制度共享对象可以是不可变对象和事实不可变对象。

  - 线程安全共享
    > 多个线程可以通过对象的公共接口对对象进行访问，不需要进一步的同步

  - 保护对象
    > 被保护的对象只能通过持有特定的锁来进行访问。

## 2 对象的组合
###
